---
date: "2022-08-13"
title: "tWIL 2022.08 2주차"
draft: true
summary: "This week I learned"
featured: /static/images/2022/08/tWIL.JPG
categories:
  - development
tags:
  - typescript
  - generate api key
---

## API Key 생성

여러 마이크로 서비스에서 메인으로 동작하는 모놀리식 API에 접근할 경우가 있다. 느슨한 연결에서도 서로의 데이터는 필요하면서 DB에 값을 쓸 경우도 있기도 하고, 데이터를 주고 받는 일은 불가피하다. 여러 방법을 찾아보았다. 그 중에 JWT를 사용하여 인증토큰을 설정하는 방법도 있지만 payload의 값의 보안을 유지해야할 필요가 있을 수 있다. 그런 경우의 API 토큰 workaround 를 찾아 보았지만 best practice를 설명한 곳이 없었다. [PEM키를 만들어서 private키와 public키를 만들어 쓰는 예제](https://stackoverflow.com/questions/55009503/how-services-generate-and-use-public-and-secret-api-keys)는 클라이언트에 public 키를 담기에도 사이즈가 너무 크고, Redis 같은 곳에 랜덤키를 발급하고 저장 한 후에 API요청이 있을 때 마다 키를 찾는 방식이 있었고, [해시값을 `salt`로 생성하는 방식](https://shahid.pro/blog/2021/09/22/how-to-generate-api-key-and-secret-to-protect-api/) (이것은 `password`값을 DB에 저장할 때 많이 쓰임)의 문제는 누구든지 payload를 알 수 없고, payload값을 비교해서 일치하는지 여부만 있었다. 그리고 나머지 대부분은 클라이언트에서 요청할때 만드는 키의 예제들이었다. 하지만 비밀키를 API만 알고 있고 DB 쿼리를 하지 않으며, Payload값을 서버만 알 수 있는 방법은 찾기 어려웠다.

생각한 방식에서는 JSON Web token을 사용하는 방식이 있는데, Payload 내용까지 암호화(encrypt) 하여 토큰을 만들 수 있겠다. 이것도 괜찮은 방법이긴 하다. 하지만 Payload의 키를 굳이 누군가가 읽어야 할 필요가 없기 때문에 best practice라고 보기 어려울 것 같다. 결국 [Node API](https://nodejs.org/dist/latest-v16.x/docs/api/crypto.html)의 `crypto`를 사용하여 만들어 보았다.

여기서는 `appKey`와 `secretKey`를 발급하여 마이크로 서비스의 환경변수에 셋팅하기 위한 방법을 [Node API](https://nodejs.org/dist/latest-v16.x/docs/api/crypto.html#class-cipher)를 참고하여 구현하였다. 필요하다면 만료일을 Payload에 담지 않고도 이 2개의 키(만료일 필드 없이)를 JSON Web token(만료일 셋팅)에 담아서 인증토큰에 셋팅하는 방법도 구현해도 될 것 같다. 이 만료일 부분은 요청 시점에 키에 대한 유효시점을 둘 지, 발급한 키 자체의 유효기간을 설정할지 아래 함수를 사용하는 사람의 정책에 따라 유연하게 쓸 수 있을 것 같다.

### API Key generator

Generating `appKey` and `secretKey` by using `privateKey`(length: 16) 여기서는 `privateKey`를 Initialization vector로 활용하며, API가 노출시키면 안되는 키로 설정한다.

`Payload`는 마이크로 서비스의 정보를 담을 임의의 타입이다. 여기서는 내가 사용할 타입으로 만들었고, 키 자체의 보안 강화를 위해 `expiredAt`을 설정하여 키를 만료시켜야할 필요도 있다.

```typescript:createApiKey.ts
import { createHmac, randomBytes, createCipheriv } from "crypto";

export enum Env {
  dev = "development",
  prod = "production",
}

export interface Payload {
  serviceName: string;
  appId: string;
  env: Env;
  issuedAt: Date;
  expiredAt: Date;
}
/**
 * It takes a private key and a payload, and returns an appKey and a secretKey
 * @param {string} privateKey - The private key that you can find in your account settings.
 * @param {Payload} payload - This is the data that you want to encrypt.
 * @returns An object with two keys, appKey and secretKey.
 */
export function createApiKey(privateKey: string, payload: Payload) {
  const key = randomBytes(16);
  const appKey = createHmac("sha256", privateKey)
    .update(key)
    .digest("hex")
    .substring(0, 16);
  const cipher = createCipheriv("aes-256-cbc", Buffer.from(privateKey), appKey);
  const encrypted = cipher.update(JSON.stringify(payload));
  const secretBuffer = Buffer.concat([encrypted, cipher.final()]).toString(
    "base64",
  );
  const secretKey = Buffer.from(secretBuffer, "utf8").toString("base64");
  return { appKey, secretKey };
}
```

이 함수는 16자리 `privateKey`를 받아 `payload`값을 저장하는 `appKey`와 `secretKey`를 생성한다. `privateKey`는 API secret 환경변수에 저장되어 있어야 하고 노출되면 안된다.

### Validating & Check payload

Node API의 `crypto`의 `createDecipheriv` 함수를 사용하여 `privateKey`를 받아 `secretKey`에 담긴 `payload`를 얻는다.

```typescript:verifyApiKey.ts
import { createDecipheriv } from "crypto";

/**
 * It decrypts the secret key using the private key and app key
 * @param {string} privateKey - The private key that was generated when the app was created.
 * @param {string} appKey - The app key that you received from the API.
 * @param {string} secretKey - The secret key that you received from the API.
 * @returns Payload string
 */
export function verifyApiKey(
  privateKey: string,
  appKey: string,
  secretKey: string,
) {
  const secretKeyDecoded = Buffer.from(secretKey, "base64").toString("ascii");
  const decryptor = createDecipheriv("aes-256-cbc", privateKey, appKey);
  const payloadString = `${decryptor.update(
    secretKeyDecoded,
    "base64",
    "utf8",
  )}${decryptor.final("utf8")}`;
  return payloadString;
}
```

`JSON.stringify()`하여 `string`으로 넘겼기 때문에 이 Payload `string`값을 `JSON.parse()` 해야한다. 하지만 이 `JSON` 형태의 `string`이 아닌 경우 `JSON.parse()`는 오류를 발생시킨다. 이 오류가 발생할 경우 `catch`도 하면서 우리가 정해놓은 `Payload` 타입을 가지고 Open API specification 스키마를 만든 후 이 Payload 값을 validation을 해야 정상적으로 Payload 값이 넘어 왔음을 확정할 수 있다.

직접 OAS 스키마를 만들어도 좋으나, 여기서 자동화 해주는 CLI 패키지 [typescript-json-validator](https://github.com/ForbesLindesay/typescript-json-validator)가 있다.

아래의 `Payload`타입에 대한 validator를 생성하면

```typescript
export interface Payload {
  serviceName: string;
  appId: string;
  env: Env;
  /**
   * @TJS-format date
   */
  issuedAt: Date;
  /**
   * @TJS-format date
   */
  expiredAt: Date;
}
```

```sh
npx typescript-json-validator src/createApiKey.ts Payload
```

실행하면, `src/createApiKey.validator.ts`가 생성된다. 파일명에 `validator`를 postFix 한 validator이다.

아래는 자동 생성된 validator 이다.

```typescript:createApiKey.validator.ts
/* tslint:disable */
// generated by typescript-json-validator
import { inspect } from "util";
import Ajv = require("ajv");
import Payload from "./createApiKey";
export const ajv = new Ajv({
  allErrors: true,
  coerceTypes: false,
  format: "fast",
  nullable: true,
  unicode: true,
  uniqueItems: true,
  useDefaults: true,
});

ajv.addMetaSchema(require("ajv/lib/refs/json-schema-draft-06.json"));

export { Payload };
export const PayloadSchema = {
  $schema: "http://json-schema.org/draft-07/schema#",
  defaultProperties: [],
  definitions: {
    Env: {
      enum: ["development", "production"],
      type: "string",
    },
  },
  properties: {
    appId: {
      type: "string",
    },
    env: {
      $ref: "#/definitions/Env",
    },
    expiredAt: {
      description: "Enables basic storage and retrieval of dates and times.",
      format: "date-time",
      type: "string",
    },
    issuedAt: {
      description: "Enables basic storage and retrieval of dates and times.",
      format: "date-time",
      type: "string",
    },
    serviceName: {
      type: "string",
    },
  },
  required: ["appId", "env", "expiredAt", "issuedAt", "serviceName"],
  type: "object",
};
export type ValidateFunction<T> = ((data: unknown) => data is T) &
  Pick<Ajv.ValidateFunction, "errors">;
export const isPayload = ajv.compile(
  PayloadSchema,
) as ValidateFunction<Payload>;
export default function validate(value: unknown): Payload {
  if (isPayload(value)) {
    return value;
  } else {
    throw new Error(
      ajv.errorsText(
        isPayload.errors!.filter((e: any) => e.keyword !== "if"),
        { dataVar: "Payload" },
      ) +
        "\n\n" +
        inspect(value),
    );
  }
}
```

쓰기 편한 이름으로 파일명을 변경하고, 몇가지 수정해야할 부분이 있다. `interface Payload`는 named export 했으므로 변경하고, `json-schema-draft-06.json`를 상단에 `import`한다. 따라서 `tsconfig.json` 설정에서 `"resolveJsonModule": true` 켜준다.

`validate`함수의 인자는 `unknown`이 아니라 `string`으로 변경하고, 여기서 `JSON.parse()`를 수행하도록 한다. 수정된 validator는

```typescript:validator.ts
/* tslint:disable */
// generated by typescript-json-validator
import { inspect } from "util";
import Ajv from "ajv";
import schema from "ajv/lib/refs/json-schema-draft-06.json";
import { Payload } from "./createApiKey";
export const ajv = new Ajv({
  allErrors: true,
  coerceTypes: false,
  format: "fast",
  nullable: true,
  unicode: true,
  uniqueItems: true,
  useDefaults: true,
});

ajv.addMetaSchema(schema);

export { Payload };
export const PayloadSchema = {
  $schema: "http://json-schema.org/draft-07/schema#",
  defaultProperties: [],
  definitions: {
    Env: {
      enum: ["development", "production"],
      type: "string",
    },
  },
  properties: {
    appId: {
      type: "string",
    },
    env: {
      $ref: "#/definitions/Env",
    },
    expiredAt: {
      description: "Enables basic storage and retrieval of dates and times.",
      format: "date-time",
      type: "string",
    },
    issuedAt: {
      description: "Enables basic storage and retrieval of dates and times.",
      format: "date-time",
      type: "string",
    },
    serviceName: {
      type: "string",
    },
  },
  required: ["appId", "env", "expiredAt", "issuedAt", "serviceName"],
  type: "object",
};
export type ValidateFunction<T> = ((data: unknown) => data is T) &
  Pick<Ajv.ValidateFunction, "errors">;
export const isPayload = ajv.compile(
  PayloadSchema,
) as ValidateFunction<Payload>;
export default function validate(value: string): Payload {
  const payload = JSON.parse(value);
  if (isPayload(payload)) {
    return payload;
  } else {
    throw new Error(
      ajv.errorsText(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        isPayload.errors!.filter((e: any) => e.keyword !== "if"),
        { dataVar: "Payload" },
      ) +
        "\n\n" +
        inspect(payload),
    );
  }
}
```

Payload validator를 만들었다. 이제 `verifyApiKey` 함수에 적용해보면,

```typescript:verifyApiKey.ts
import { createDecipheriv } from "crypto";
import payloadValidator from "./validator";

/**
 * It decrypts the secret key using the private key and app key
 * @param {string} privateKey - The private key that was generated when the app was created.
 * @param {string} appKey - The app key that you received from the API.
 * @param {string} secretKey - The secret key that you received from the API.
 * @returns The secret key
 */
export function verifyApiKey(
  privateKey: string,
  appKey: string,
  secretKey: string,
) {
  const secretKeyDecoded = Buffer.from(secretKey, "base64").toString("ascii");
  const decryptor = createDecipheriv("aes-256-cbc", privateKey, appKey);
  const payloadString = `${decryptor.update(
    secretKeyDecoded,
    "base64",
    "utf8",
  )}${decryptor.final("utf8")}`;
  const payload = payloadValidator(payloadString);
  return payload;
}
```

마지막 이 `validator`에 원하는 조건을 더 추가할 수 있다. 예를들어 등록된 `appId`인지 확인하는 방법도 있을 수 있고, 키의 만료일이 지났는지 등 API 정책에 맞게 수정하면 된다.

#### Testing

[generate-api-key](https://github.com/pauldenver/generate-api-key) 패키지를 사용하여 16자리 `privateKey`를 생성한다. 그리고 키 생성 및 키 검증을 수행해본다.

```typescript:testing.ts
import { createApiKey } from "./createApiKey";
import { generateApiKey } from "generate-api-key";

const privateKey = gen({ length: 16 });
const key = createApiKey(pk, payload);

const payload: Payload = {
  serviceName: "AWS Lambda",
  appId: "lambda-12345678",
  env: Env.dev,
  issuedAt: new Date(),
  expiredAt: new Date("2100-12-31T15:00:00.000Z"),
};

// API 키 생성
const key = createApiKey(pk, payload);

console.log(key);
//
// {
//   appKey: 'e7e1b79d7a86a775',
//   secretKey: 'bWlHTnVTN2VQdURXajBGZHdxN3JGT05NTmlKcmZ3TTFtL2l6RkErSzUzdXVuSEVQVW0zY1B4bXJJZjMwTG1zN0crZnp6ZmtMMWxtVzhPZ0tvbWE4L1VlejNuOUtpbDZ6OVVwS0pEdEQzTkUvYzBTS29xamxETjFuRVJzMHJlaW5YQ0h2QXBJbmJFMXpNcDVMSUVNRmlocVErQ0w5Z2lJWkJvQWdRemdLMlNhem9scnVmNS9iL0IwT3pLWVBKLzlOVkc1WEdzQVYrZk1BSFlROWlFODJZdz09'
// }

// API 키 검증
const result = verifyApiKey(pk, key.appKey, key.secretKey);

// Payload
console.log(result);
//
// {
//   serviceName: 'AWS Lambda',
//   appId: 'lambda-12345678',
//   env: 'development',
//   issuedAt: '2022-08-09T15:56:54.762Z',
//   expiredAt: '2100-12-31T15:00:00.000Z'
// }
```
